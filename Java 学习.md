# Java 学习



## 什么是面向对象



### 面向对象与面向过程

> Java 是一种面向对象的开发语言. 所谓面向对象, 其实是指软件工程中的一类编程风格



#### 什么是面向过程?

面向过程(procedure Oriented) 是一种以过程为中心的编程思想, 是一种自定而下的编程模式. 最典型的面向过程编程语言就是 C 语言

简单来说面向过程的开发范式中, 程序员需要把问题分解成一个一个步骤, 每个步骤用函数实现, 依次调用即可

就是说, 在面向过程编程的时候, 不需要考虑那么多, 上来先定义一个函数, 然后使用诸如  if-else, for-each 等方式进行代码执行. 最典型的用法就是实现一个简单的算法, 比如实现冒泡排序.

面向过程进行的软件开发, 其代码都是流程化的, 很明确的可以看出第一步做什么, 第二步做什么. 这种方式的代码执行起来效率很高. 

但是, 面向过程同时存在着代码重用性低, 扩展能力差, 后期维护难度比较大等问题.



#### 什么是面向对象?

面向对象 (Object Oriented) 的雏形, 最早出现在1960年的Simula语言中, 当时的程序设计领域正面临着一种危机: 在软硬件环境逐渐复杂的情况下, 软件如何得到良好的维护?

面向对象程序设计在某种程度上通过强调可重复性解决了这一问题. 目前较为流行的面向对象语言主要有 Java, C#, C++, Python, Puby, PHP等.

简单来说, 面向对象的开发范式中, 程序员将问题分解成一个一个步骤, 对每个步骤进行相应的抽象, 形成对象, 通过不同对象之间的调用, 组合解决问题.

就是说, 在进行面向对象进行编程的时候, 要把属性、行为等封装成对象, 然后基于这些对象及对象的能力进行业务逻辑的实现. 比如想要造一辆车, 上来要先把车的各种属性定义出来, 然后抽象成一个 Car 类.

面向对象的编程之所以更加受欢迎, 是因为他更加符合人类的思维方式. 这种方式编写出来的代码可扩展性、可维护性都很高.

与其面向对象是一种开发范式, 倒不如说面向对象是一种对现实世界的理解和抽象的方法. 通过对现实世界的理解和抽象, 在运用封装、继承、多态等方式, 通过抽象出对象的方法进行软件开发.



### 面向对象的三大基本特征

> 我们说面向对象的开发范式, 其实是对现实世界的理解和抽象的方法, 那么, 具体如何将现实世界抽象成代码呢? 这就需要运用到面向对象的三大特性, 分别是 ***封装性***、***继承性*** 和 ***多态性***.



#### 封装 (Encapsulation)

所谓封装, 也就是把客观事物封装成抽象的类, 并且类可以把自己的数据和方法只让可信的类或者对象操作, 对不可信的进行信息隐藏.

简单的说, 一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体. 在一个对象内部, 某些代码或某些数据是可以私有的, 不能被外界访问. 通过这种方式, 对象对内部数据提供了不同级别的保护, 以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分.



##### 封装举例

如我们想要定义一个矩形, 先定义一个 Rectangle 类, 并其中通过封装的手段放入一些必备数据.

~~~ java
/**
* 矩形
*/
class Rectangle {
  
  /** 
  * 设置矩形的长度和宽度
  */
  
  public Rectangle(int length, int width) {
    this.length = lenght;
    this.width = width;
  }
  
  /**
  * 长度
  */
  private int length;
  
  /**
  * 宽度
  */
  private int width;
  
  /**
  * 获得矩形体积
  * 
  * @return 
  */
  public int area(){
    return this.length * this.width;
  }
}
~~~

我们通过封装的方式, 给 矩形 定义了 长度 和 宽度, 这就完成了对现实世界中的矩形的抽象的第一步.



#### 继承 (Inheritance)

继承是这样一种能力: 它可以使用现有类的所有功能, 并在无需重新编写原来的类的情况下对这些功能进行扩展.

通过继承创建的新类称为 “子类” 或 “派生类”, 被继承的类为 “基类”、“父类” 或 “超类”. 继承的过程, 就是从一般到特殊的过程.



##### 继承举例

我们想要定义一个正方形, 因为已经有了矩形, 所以我们可以直接继承 Rectangle 类, 因为正方形是长方形的一种特例.

~~~java
/**
* 正方形, 继承自矩形
*/

class Square extends Rectangle {
  /**
  * 设置正方形的长
  *
  * @param length
  */
  public Square(int length) {
    super(length, length);
  }
}
~~~

现实世界中, 正方形是矩形的特例, 或者说正方形使用过矩形派生出来的, 这种派生关系, 在面向对象中可以用继承来表达.



#### 多态 (Polymorphism)

所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式. 多态机制使具有不同内部结构的对象可以共享相同的外部接口.

这意味着, 虽然针对不同对象的具体操作不同, 但通过一个公共的类, 它们 (那些操作) 可以通过相同的方法予以调用.

最常见的多态就是将子类传入父类参数中, 运用时调用父类方法时通过传入的子类决定具体的内部结构或行为.



### 面向对象的五大原则



####单一职责原则 (Single-Responsibility Principle)

其核心思想为: 一个类, 最好只做一件事, 只有一个引起它的变化.

单一职责原则可以看作是低耦合、高内聚在面向对象原则的引申, 将职责定义为引起变化的原因, 以提高内聚性来减少引起变化的原因. 职责过多, 可能引起它变化的原因越多, 这将导致职责依赖, 想画之间就产生影响, 从而大大损伤其内聚性和耦合度. 通常意义下的单一职责, 就是指只有一种单一功能, 不要为类实现过多的功能点, 以保证实体只有一个引起它变化的原因. 专注, 是一个人的优良品质; 同样的, 单一也是一个类的优良设计. 交杂不清的职责将使得代码看起来特别别扭牵一发而动全身, 有失美感和必然导致丑陋的系统错误风险. 



#### 开放封闭原则 (Open-Closed principle)

其思想就是: 软件实体应该是可扩展的, 而不可修改的. 也就是, 对扩展开放, 对修改封闭.

开放封闭原则主要体现在两个方面:

1. 对扩展开放, 意味着有新的需求或变化时, 可以对现有代码进行扩展, 以适应新的情况
2. 对修改封闭, 意味着类一旦设计完成, 就可以独立完成其工作, 而不要对其进行任何尝试的修改. 

实现开放封闭原则的核心思想就是对抽象编程, 而不对具体编程, 因为抽象相对稳定. 让类依赖于固定的抽象, 所以修改是封闭的; 而通过面向对象的继承和多态机制, 又可以实现对抽象类的继承, 通过覆写起方法来改变固有行为, 实现新的拓展方法, 所以就是开放的. “需求总是变化的”, 没有不变的软件, 所以就需要用封闭开放原则来封闭变化满足需求, 同时还能保持软件内部的封装体系稳定, 不被需求的变化影响. 



#### 里氏替换原则  (Liskov-Substitution Principle)

其核心思想就是: 子类必须能够替换其基类. 这一思想体现为对继承机制的约束规范, 只有子类能够替换基类时, 才能保证系统在运行期内识别子类, 这是保证继承复用的基础.

在父类和子类的具体行为中, 必须严格把握继承层次中的关系和特征, 将基类替换为子类, 程序的行为不会发生任何变化. 同时, 这一约束反过来则是不成立的, 子类可以替换基类, 但是基类不一定能替换子类. 里式替换原则, 主要着眼于对抽象和多态建立在继承的基础上, 因此只有遵循了Liskov替换原则, 才能保证继承复用是可靠地. 实现的方法是面向接口编程: 将公共部分抽象为基类接口或抽象类, 通过 Extract Abstract Class, 在子类通过覆写父类的方法实现新的方式支持同样的职责.

里氏替换原则是关于继承机制的设计原则, 违反了 Liskov 替换原则就必然导致违反开放封闭原则.

里氏替换原则能够保证系统具有良好的扩展性, 同时实现基于多态的抽象机制, 能够减少代码冗余, 避免运行期的类别判别.



#### 依赖倒置原则 (Dependency-Inversion Principle)

其核心思想就是: 依赖于抽象. 具体而言就是高层模块不依赖于底层模块, 二者都同依赖于抽象; 抽象不依赖于具体, 具体依赖于抽象.

我们知道, 依赖一定会存在与类与类、模块与模块之间. 当两个模块之间存在紧密的耦合关系时候, 最好的方法就是分离接口和实现: 在依赖之间定义一个抽象的接口使得高层模块调用接口, 而底层模块实现接口的定义, 依次来有效控制耦合关系, 达到依赖于抽象的设计目标. 抽象的稳定性决定了系统的稳定性. 因为抽象是不变的, 依赖于抽象是面向对象设计的精髓, 也是依赖倒置原则的核心.

依赖于抽象是一个通用的原则, 而某些时候依赖于细节则是在所难免的, 必须权衡在抽象和具体之间的取舍, 方法不是一层不变的. 依赖于抽象, 就是对线口编程, 不要对实现编程.



#### 接口隔离原则 (Interface-Segregation Principle)

其核心思想就是: 使用多个小的接口, 而不要使用一个大的总接口.

具体而言, 接口隔离原则体现在: 接口应该是内聚的, 应该避免胖接口



